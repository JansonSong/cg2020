# 2 算法介绍

## 2.1 绘制直线算法

### 2.1.1 DDA算法

直线的方程为$y = mx + b$，其中，$m$表示直线的斜率，$b$是y轴截距。
给定线段的两个端点$(x_0; y_0)$和$(x_1; y_1)$，可以计算出斜率$m$和截距$b$：
$$
\begin{cases} 
m=\displaystyle\frac{y_1-y_0}{x_1-x_0}, x_1 \neq x_0 \\
b=y_1-mx_1
\end{cases}
$$
下面仅考虑$0\leq m \leq 1$的情况：

​		在这种情况下，由于像素是呈离散状态的，对于任意两个像素点$(x_i, y_i)$和点$(x_j,y_j)$，都有$x_i \neq x_j$，并且$x$的取值是连续的，所以有$x_{k+1} = x_k+1$，在单位$x$间隔($\delta x=1$)采样并计算每个对应的$y$值，$y_{k+1}=y_k+m$，其中，下标$k$取整数值，并从第一个点$x_0$开始递增，直至最后端点。由于$m$是$0$~$1$之间的任意实数，所以计算像素点$y$坐标值的时候，需要取整。

对于$m$一般的情况，求出$|\Delta x|$和$|\Delta y|$，取其中大的一方，假设$|\Delta x|$大，那么将直线$x$坐标按单位分割，$x_{k+1} = x_k+signx$，其中$signx=\displaystyle\frac{x_1-x_0}{\Delta x}$表示绘制像素时$x$移动的单位方向，那么$y_{k+1}=y_k+\displaystyle\frac{y_1-y_0}{\Delta x}$。



### 2.1.2 Bresenham算法

直线方程如上述算法中所示。

**下面也考虑$0\leq m \leq 1$的情况：**

​		在这种情况下，由于像素是呈离散状态的，对于任意两个像素点$(x_i, y_i)$和点$(x_j,y_j)$，都有$x_i \neq x_j$，并且$x$的取值是连续的，所以有$x_{k+1} = x_k+1$，在单位$x$间隔($\delta x=1$)采样并计算每个对应的$y$值，此时$y_{k+1}$有两种取值，第一种是$y_k$，第二种是$y_k+1$，

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200926191821822.png" alt="image-20200926191821822" style="zoom:80%;" />

​		如上图所示，$y_{k+1}$的取值决定原直线上对应的点，到哪个点的距离最近，即根据$d_1$和$d_2$的大小决定。
$$
\begin{cases} 

y_{k+1}=y_k,d_1\leq d_2 \\

y_{k+1}=y_k+1,d_1 > d_2

\end{cases}
$$
直线在横坐标为$x_{k+1}$处的值为$y=m(x_k+1)+b$，那么两个候选像素与原直线上的值的垂直偏移分别为：
$$
\begin{cases} 

d_1=y-y_k=m(x_k+1)+b-y_k \\

d_2=y_{k+1}-y=y_k+1-m(x_k+1)-b

\end{cases}
$$
这两个垂直偏移的差值为：

$$d_1-d2=2m(x_k+1)-2y_k+2b+1$$，设$\Delta x = x_1-x_0$和$\Delta y = y_1-y_0$，则$m=\displaystyle\frac{\Delta y}{\Delta x}$，那么令$p_k=\Delta x(d_1-d_2)=2\Delta yx_k-2\Delta xy_k+c$，其中$c = 2\Delta y+(2b-1)\Delta x$是常量，所以可以提前把$c$计算出来。

在这里只考虑起始点的$x_0$坐标小于终点的$x_1$坐标（如果$x_0>x_1$，可以令两个坐标调换位置），那么$\Delta x$肯定就为整数，那么如果$p_k\leq 0$，那么$d_1\leq d_2$，所以选择点$(x_{k+1}, y_k)$，否则选择点$(x_{k+1}, y_k+1)$。

如果循环次数过多，计算$p_k$时，要做很多次乘法，显然是很消耗时间的，所以要考虑如果将乘法运算通过迭代的方式尽量的减少。考虑$p_{k+1}-p_k=2\Delta y-2\Delta x(y_{k+1}-y_k)$，即$p_{k+1}=p_k+2\Delta y-2\Delta x(y_{k+1}-y_k)$，所以$p_{k+1}$的取值取决于选取哪一个像素点，即
$$
p_{k+1}=
\begin{cases} 
p_k+2\Delta y,  & p_k \leq 0 \\
p_k+2\Delta y-2\Delta x, & p_k>0
\end{cases}
$$
那么此时，提前计算出$2\Delta x$和$2\Delta y$，每次迭代计算的时候，只需要计算加法就可以了，所以当需要的像素点特别多时，可以节省很多时间。

根据公式，可以计算出$p_0=2\Delta yx_0-\Delta xy_0+c$，在迭代的过程中，可以知道该选择哪一个像素点，并且计算出下一个$p_k$的值。

**再考虑一般$m$的情况：**

首先计算出$|\Delta x|$和$|\Delta y|$，如果$|\Delta x|< |\Delta y|$，那么将两个端点的$x$和$y$坐标调换一下位置，那么就只需要考虑$|m|\leq 1$的情况了，如果$x_0>x_1$，那么可以将起点坐标和终点坐标调换位置，那么就只需要考虑在单位$x$间隔($\delta x=1$)采样，并计算出$y_{k+1}$的取值。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200926205158312.png" alt="image-20200926205158312" style="zoom:50%;" />

根据上述调整转换之后，本来需要考虑8种情况的，现在只需要考虑2种情况。情况1与情况2，只有y坐标的取值是相反的，但他们上升与下降的趋势是相同的，即何时加1与何时减1是相同的，所以，需要考虑一个标识符$signy$，情况1时，$signy=1$，情况2时，$signy=-1$，根据上述考虑的特殊情况可以得出以下几个不同的地方，即
$$
\begin{aligned}
&c =2\Delta y+(2b-signy)\Delta x\\
&p_{k+1}=
\begin{cases} 
signy(p_k+2\Delta y),  & p_k \leq 0 \\
signy(p_k+2\Delta y-2signy\Delta x), & p_k>0
\end{cases}
\end{aligned}
$$
并且如果$y_{k+1}\neq y_k$，那么$y_{k+1}=y_k+signy$，其余情况都和上述特殊情况差不多。



## 2.2 绘制椭圆算法

### 中心椭圆生成算法

椭圆的方程为$\displaystyle\frac{(x-x_c)^2}{a^2}+\frac{(y-y_c)^2}{b^2}=1$，下面只考虑椭圆心在坐标原点上（如果不在坐标原点，可以通过移动像素点来实现对椭圆的移动）且$a\geq b$（如果$a<b$，可以考虑调换一下$x$和$y$坐标），即只需要考虑椭圆方程$\displaystyle\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$，给定椭圆的矩形包围框左上角和右下角顶点坐标$(x_0, y_0)$和$(x_1, y_1)$，可以计算出椭圆方程中的$a$和$b$，
$$
\begin{cases} 
a=\displaystyle\frac{x_1-x_0}{2} \\
b=\displaystyle\frac{y_0-y_1}{2}
\end{cases}
$$
椭圆上点$(x_i, y_i)$的切线斜率是$k=-\displaystyle\frac{b^2 x_i}{a^2 y_i}$，

由于椭圆在四个象限中的图像都是一样的，可以通过某个象限中的图像得到另外三个象限的，所以，

**下面仅考虑椭圆在第一象限的图像。**

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200927124026589.png" alt="image-20200927124026589" style="zoom:60%;" />

中心椭圆方法依据椭圆上点的切线斜率，将第一象限的椭圆分成两部分，即区域1和区域2，如上图所示，这里是根据斜率为-1进行划分，根据直线绘制算法，可以知道，在区域1中，$x$方向取单位步长，$y_{k+1}$有两种取值$\{y_k, y_k+1\}$，在区域2中，$y$方向取单位步长，$x_{k+1}$有两种取值$\{x_k, x_k+1\}$，所以要分开来讨论，这两个区域的临界条件是$k=-1$，即$b^2 x_i=a^2 y_i$。

定义椭圆的函数为：
$$
f_{ellipse}(x, y) = b^2x^2+a^2y^2-a^2b^2
$$


对于椭圆方程有如下特性：
$$
\begin{cases} 
f_{ellipse}(x, y)<0，(x,y)位于椭圆周边内 \\
f_{ellipse}(x, y)=0，(x,y)位于椭圆周边上\\
f_{ellipse}(x, y)>0，(x,y)位于椭圆周边外
\end{cases}
$$
从$(0, b)$开始，在$x$方向取单位步长步进到区域1和区域2之间的边界，然后转换成$y$方向的单位步长通过第一象限中剩余的曲线段，从当前像素点选择下一个像素点时，都有两种选择，那么可以通过判断这两个像素点的中点，与椭圆周边的位置关系来判断选择哪一个像素点。**（1）在区域1中（$|切线斜率|\leq 1$）**

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200927162119140.png" alt="image-20200927162119140" style="zoom:80%;" />

考虑选择点$(x_k,y_k)$下一个像素点，有两个选择$(x_{k+1},y_k)$和$(x_{k+1},y_k-1)$，此时考虑这两个点的中点满足的椭圆方程特性，即：
$$
p_k=f_{ellipse}(x_{k+1},y_k-\displaystyle\frac{1}{2})=b^2(x_k+1)^2+a^2(y_k-\frac{1}{2})^2-a^2b^2
$$
如果$p_k<0$，中点位于椭圆周边内，$(x_{k+1},y_k)$更接近于椭圆边界，所以选择像素点$(x_{k+1},y_k)$；如果$p_k\geq 0$，中位点位于椭圆周边上或周边外，所以选择像素点$(x_{k+1},y_k-1)$。

如果循环次数过多，计算$p_k$时，要做很多次乘法，显然是很消耗时间的，所以要考虑如果将乘法运算通过迭代的方式尽量的减少。考虑$p_{k+1}-p_k=2b^2x_k+3b^2+a^2(y_{k+1}^2-y_k^2)-a^2(y_{k+1}-y_k)$，所以$p_{k+1}$的取值取决于选取哪一个像素点，即
$$
p_{k+1}=
\begin{cases} 
p_k+2b^2x_k+3b^2,  & p_k < 0 \\
p_k+2b^2x_k-2a^2y_k+2a^2+3b^2, & p_k\geq 0
\end{cases}
$$
那么此时，提前计算出$2b^2$、$3b^2$、$2a^2$，每次迭代计算的时候，就可以减少很多的乘法操作，所以当需要的像素点特别多时，可以节省很多时间，根据公式可以计算出$\displaystyle p_0 = b^2-a^2b+\frac{1}{4}a^2$

**（2）在区域2中（$|切线斜率|> 1$）**

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200927164353656.png" alt="image-20200927164353656" style="zoom:60%;" />

考虑选择点$(x_k,y_k)$下一个像素点，有两个选择$(x_k,y_{k+1})$和$(x_k+1,y_{k+1})$，此时考虑这两个点的中点满足的椭圆方程特性，即：
$$
\displaystyle p_k=f_{ellipse}(x_k+\frac{1}{2},y_{k+1})=b^2(x_k+\frac{1}{2})^2+a^2(y_k-1)^2-a^2b^2
$$
如果$p_k\leq0$，中点位于椭圆周边内，$(x_k+1,y_{k+1})$更接近于椭圆边界，所以选择像素点$(x_k+1,y_{k+1})$；如果$p_k> 0$，中位点位于椭圆周边上或周边外，所以选择像素点$(x_k,y_{k+1})$。

如果循环次数过多，计算$p_k$时，要做很多次乘法，显然是很消耗时间的，所以要考虑如果将乘法运算通过迭代的方式尽量的减少。考虑$p_{k+1}-p_k=b^2(x_{k+1}^2-x_k^2)+b^2(x_{k+1}-x_k)-2a^2y_k+3a^2$，所以$p_{k+1}$的取值取决于选取哪一个像素点，即
$$
p_{k+1}=
\begin{cases} 
p_k+2b^2x_k-2a^2y_k+2b^2+3a^2,  & p_k \leq 0 \\
p_k-2a^2y_k+3a^2, & p_k> 0
\end{cases}
$$
那么此时，提前计算出$2a^2$、$3b^2$、$3a^2$，每次迭代计算的时候，就可以减少很多的乘法操作，所以当需要的像素点特别多时，可以节省很多时间。

**再考虑椭圆的其他象限：**

第二象限，只需要将第一象限中的横坐标，做关于$y$轴的对称变换。

第四象限，只需要将第一象限中的纵坐标，做关于$x$轴的对称变换。

第三象限，只需要将第二象限中的纵坐标，做关于$x$轴的对称变换。



### 2.3 绘制曲线算法

### 2.3.1 Bézier​算法

$n$次$Bernstein$基函数的多项式形式为$BEZ_{i, n}(u)=C_n^iu^i(1-u)^{n-i}$，其中
$$
C_n^i=\displaystyle\frac{n!}{i!(n-i)!}(i=0,1,...,n)
$$
Bézier​曲线是通过一组多边折线的各顶点唯一定义出来的，曲线的形状趋向于多边折线的形状，改变多边折线的顶点坐标位置和曲线的形状有紧密的联系。因此，多边折线通常称为特征多边形，其顶点称为控制顶点。

给出$n+1$个控制顶点位置$P_i=(x_i, y_i)(i=0,1,2,...,n)$，这些坐标点混合产生下列位置向量$P(u)$，用来描述$P_0$和$P_n$间的逼近Bézier多项式函数的曲线。
$$
P(u)=\sum_{i=0}^n P_iBEZ_{i, n}(u)(0\leq u \leq 1)
$$


